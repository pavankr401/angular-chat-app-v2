# Data structures

## Array

### **What is an Array?**

- An **array** is a linear data structure that stores elements of the same type in contiguous memory locations.
- Elements are accessed using **indices**, starting from 0.

------

### **Key Features of Arrays**

1. **Fixed Size**: The size of an array is typically defined at creation and cannot change (in fixed-size arrays).
2. **Homogeneous Data**: All elements in an array are of the same data type.
3. **Random Access**: Allows direct access to elements using their index.

------

### **Pros of Arrays**

1. Fast Access:
   - Random access to elements using indices is **O(1)**.
2. Efficient for Iteration:
   - Arrays allow easy traversal and manipulation using loops.
3. Memory Efficiency:
   - Contiguous memory storage minimizes overhead and improves cache performance.
4. Ease of Use:
   - Arrays are simple to understand and implement for basic problems.
5. Foundation for Other Data Structures:
   - Arrays are used to build advanced structures like stacks, queues, heaps, and hash tables.

------

### **Cons of Arrays**

1. Fixed Size:
   - In fixed arrays, the size must be declared at creation and cannot change dynamically.
2. Insertion and Deletion Cost:
   - Adding/removing elements (except at the end) requires shifting elements, making it **O(n)**.
3. Wasted Space:
   - For dynamic arrays, unused allocated memory leads to **space overhead**.
4. Homogeneity:
   - All elements must be of the same type, limiting flexibility.

------

### **Use Cases of Arrays**

1. Storing collections of data (e.g., student marks, sensor readings).
2. Basis for implementing other data structures.
3. Used in algorithms requiring sequential or indexed storage (e.g., sorting and searching).

### **1. Create (Insertion)**

#### **Dynamic Array**:

- **Best Case**:
  **O(1)** â€” Adding a new element at the end when thereâ€™s free space (no resizing required).
- **Worst Case**:
  **O(n)** â€” If the array is full and needs resizing, all elements are copied to a new array with larger capacity.

#### **Fixed-Size Array**:

- **Best and Worst Case**:
  **O(1)** â€” Adding an element at a specific index (if within bounds and overwriting).

------

### **2. Read (Access)**

- **Best and Worst Case**:
  **O(1)** â€” Accessing an element by its index is always constant time, as arrays support direct indexing.

------

### **3. Update**

- **Best and Worst Case**:
  **O(1)** â€” Updating an element at a specific index is constant time because no additional operations are needed.

------

### **4. Delete**

#### **Dynamic Array**:

- **Best Case**:
  **O(1)** â€” Deleting the last element when no shifting of elements is required.
- **Worst Case**:
  **O(n)** â€” Deleting an element from the beginning or middle requires shifting all subsequent elements to fill the gap.

#### **Fixed-Size Array**:

- **Best Case**:
  **O(1)** â€” If overwriting is sufficient, such as clearing a specific index.
- **Worst Case**:
  **O(n)** â€” For shifting elements when deleting from the beginning or middle.



### **1. Static Methods (from `System.Array`)**

1. **`void Array.Clear(Array array, int index, int length)`**
   - **Explanation**: Clears (sets to default value) elements in the array from a specific index for a given length.
2. **`int Array.IndexOf(Array array, object value)`**
   - **Explanation**: Searches for the specified value in the array and returns its index. Returns `-1` if not found.
3. **`int Array.LastIndexOf(Array array, object value)`**
   - **Explanation**: Searches for the specified value starting from the end of the array and returns its last index. Returns `-1` if not found.
4. **`void Array.Copy(Array sourceArray, Array destinationArray, int length)`**
   - **Explanation**: Copies elements from the source array to the destination array.
5. **`void Array.Resize<T>(ref T[] array, int newSize)`**
   - **Explanation**: Changes the size of an array (creates a new array and copies elements).
6. **`void Array.Sort(Array array)`**
   - **Explanation**: Sorts the elements in the array in ascending order.
7. **`void Array.Reverse(Array array)`**
   - **Explanation**: Reverses the order of elements in the array.
8. **`bool Array.Exists<T>(T[] array, Predicate<T> match)`**
   - **Explanation**: Checks if any element in the array matches the specified condition.
9. **`T Array.Find<T>(T[] array, Predicate<T> match)`**
   - **Explanation**: Finds and returns the first element in the array that matches the specified condition. Returns the default value if not found.
10. **`T[] Array.FindAll<T>(T[] array, Predicate<T> match)`**
    - **Explanation**: Finds all elements in the array that match the specified condition and returns them in a new array.
11. **`int Array.BinarySearch(Array array, object value)`**
    - **Explanation**: Searches a sorted array for a value using the binary search algorithm. Returns the index of the value or a negative number if not found.
12. **`int Array.GetLength(int dimension)`**
    - **Explanation**: Returns the number of elements in a specified dimension of a multidimensional array.
13. **`int Array.GetUpperBound(int dimension)`**
    - **Explanation**: Returns the upper bound (maximum index) of a specified dimension in the array.
14. **`int Array.GetLowerBound(int dimension)`**
    - **Explanation**: Returns the lower bound (minimum index) of a specified dimension in the array.

------

### **2. Extension Methods (from `System.Linq`)**

1. **`T[] Enumerable.ToArray<T>(this IEnumerable<T> source)`**
   - **Explanation**: Converts a sequence (e.g., list) into an array.
2. **`int Enumerable.Count<T>(this IEnumerable<T> source)`**
   - **Explanation**: Returns the number of elements in a sequence.
3. **`T Enumerable.First<T>(this IEnumerable<T> source)`**
   - **Explanation**: Returns the first element of a sequence.
4. **`T Enumerable.Last<T>(this IEnumerable<T> source)`**
   - **Explanation**: Returns the last element of a sequence.
5. **`bool Enumerable.Contains<T>(this IEnumerable<T> source, T value)`**
   - **Explanation**: Checks if the sequence contains a specific value.





### **Difference Between HashMap and HashSet**

Both **HashMap** and **HashSet** use **hashing** for fast operations, but they serve different purposes.

| Feature            | **HashMap**                                       | **HashSet**                                      |
| ------------------ | ------------------------------------------------- | ------------------------------------------------ |
| **Definition**     | Stores **key-value pairs**                        | Stores **unique values only**                    |
| **Data Structure** | Implements **Dictionary<K, V>**                   | Implements **Set**                               |
| **Duplicates**     | **Keys** must be unique, values can be duplicated | **Does not allow duplicates**                    |
| **Access Time**    | O(1) on average (for insert, delete, lookup)      | O(1) on average (for insert, delete, lookup)     |
| **Usage**          | When key-value relationships are needed           | When only a collection of unique items is needed |
| **Example**        | `Dictionary<int, string>` â†’ `{1: "A", 2: "B"}`    | `HashSet<int>` â†’ `{1, 2, 3, 4}`                  |

------

### **When to Use HashMap vs HashSet**

- **Use HashMap** when you need **key-value** pairs (e.g., storing user IDs and names).
- **Use HashSet** when you only need a **unique collection of values** (e.g., storing unique user IDs).

Would you like a C# example of both? ðŸš€
